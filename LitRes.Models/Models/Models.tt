<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ output extension=".cs" #>
<#
	var content = File.ReadAllText( Path.GetDirectoryName( this.Host.TemplateFile ) + "\\Models.xml" );
#>
//-----------------
// WARNING: This code is autogenerated, do not modify it directly.
//-----------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Runtime.Serialization;

using Digillect;
using Digillect.Collections;

<#
	var document = XDocument.Parse( content );
	var model = document.Element( NS+"Model" );

	if( model.Attribute( "defaultEntitySerialization" ) != null )
	{
		defaultEntitySerializationMode = model.Attribute( "defaultEntitySerialization" ).Value;
	}

	if( model.Attribute( "defaultPropertySerialization" ) != null )
	{
		defaultPropertySerializationMode = model.Attribute( "defaultPropertySerialization" ).Value;
	}

	var usings = from u in model.Elements( NS+"Using" ) select u;

	foreach( var u in usings )
	{
#>
using <#= u.Attribute( "Namespace" ).Value #>;
<#
	}
#>

namespace <#= model.Attribute( "Namespace" ).Value #>
{
<#
	var entities = from e in model.Elements( NS+"Entity" ) select e;

	InitializeTypes();
	ProcessEntities( entities );
#>
}
<#+
	readonly XNamespace NS = "http://schemas.digillect.com/development/datamodel";
	readonly HashSet<string> valueTypes = new HashSet<string>();
	readonly HashSet<string> simpleTypes = new HashSet<string>();
	
	string defaultEntitySerializationMode = null;
	string defaultPropertySerializationMode = null;

	void InitializeTypes()
	{
		valueTypes.Add( "bool" );
		valueTypes.Add( "char" );
		valueTypes.Add( "int" );
		valueTypes.Add( "uint" );
		valueTypes.Add( "long" );
		valueTypes.Add( "ulong" );
		valueTypes.Add( "float" );
		valueTypes.Add( "double" );
		valueTypes.Add( "DateTime" );

		simpleTypes.Add( "string" );
		simpleTypes.Add( "ObservableCollection" );
	}
	
	bool IsValueTypeProperty( XElement property )
	{
		string type = property.Attribute( "Type" ).Value;

		if( valueTypes.Contains( type ) )
			return true;

		return false;
	}

	bool IsSimpleProperty( XElement property )
	{
		string type = property.Attribute( "Type" ).Value;

		if( valueTypes.Contains( type ) )
			return true;

		if( simpleTypes.Contains( type ) )
			return true;

		type = ConstructPropertyType( property );

		if( type.EndsWith( "[]" ) )
			return true;

		return false;
	}

	string ConstructBaseClassType( XElement element )
	{
		XAttribute genericArgs = element.Attribute( "BaseTypeGenericArguments" );

		if( genericArgs == null )
			return element.Attribute( "BaseType" ).Value;

		return string.Format( "{0}<{1}>", element.Attribute( "BaseType" ).Value, genericArgs.Value );
	}

	string ConstructPropertyType( XElement element )
	{
		XAttribute genericArgs = element.Attribute( "TypeGenericArguments" );

		if( genericArgs == null )
			return element.Attribute( "Type" ).Value;

		return string.Format( "{0}<{1}>", element.Attribute( "Type" ).Value, genericArgs.Value );
	}

	string EmitAttributes( XElement element )
	{
		var attrs = from a in element.Elements( NS+"Attribute" ) select a;
		StringBuilder sb = null;
		
		foreach( var a in attrs )
		{
			if( sb == null )
				sb = new StringBuilder();
			else
				sb.Append( ", " );
			
			if( a.Attribute( "Parameters" ) != null )
			{
				sb.Append( a.Attribute( "Name" ).Value )
					.Append( "( " )
					.Append( a.Attribute( "Parameters" ).Value )
					.Append( ")" );
			}
			else
			{
				sb.Append( a.Attribute( "Name" ).Value );
			}
		}
		
		return sb == null ? null : sb.ToString();
	}
	
	bool GetBooleanAttribute( XElement element, string name, bool defaultValue = false )
	{
		if( element.Attribute( name ) == null )
			return defaultValue;
		
		var value = element.Attribute( name ).Value;
		
		return value == "True" || value == "true" || value == "1";
	}

	string FieldNameForPropertyNamed( string propertyName )
	{
		return "_" + char.ToLower( propertyName[0] ) + propertyName.Substring( 1 );
	}

	void ProcessEntities( IEnumerable<XElement> entities )
	{
		foreach( var entity in entities )
		{
			var entityAttributes = EmitAttributes( entity );
			string visibility = "public";

			if( entity.Attribute( "Visibility" ) != null )
			{
				visibility = entity.Attribute( "Visibility" ).Value;
			}
#>
	#region <#= visibility #> class <#= entity.Attribute( "Name" ).Value #>
<#+
			string serializationMode = null, serializationName = null;

			if( entity.Attribute( "Serialization" ) != null )
			{
				serializationMode = entity.Attribute( "Serialization" ).Value;
			}
			else
			{
				serializationMode = defaultEntitySerializationMode ?? "contract";
			}

			if( entity.Attribute( "SerializationName" ) != null )
			{
				serializationName = entity.Attribute( "SerializationName" ).Value;
			}

			string serializationAttributeName = null, serializationAttributeParameters = null;

			switch( serializationMode )
			{
				case "xml":
					serializationAttributeName = "XmlRoot";

					if( serializationName != null )
					{
						var parts = serializationName.Split( ',' );

						if( parts.Length == 1 )
						{
							serializationAttributeParameters = "\"" + serializationName + "\"";
						}
						else
						{
							serializationAttributeParameters = string.Format( "\"{1}\", Namespace=\"{0}\"", parts[0], parts[1] );
						}
					}

					break;

				case "none":
					break;

				case "contract":
				default:
					serializationAttributeName = "DataContract";

					if( serializationName != null )
					{
						serializationAttributeParameters = "Name = \"" + serializationName + "\"";
					}

					break;
			}

			if( serializationAttributeName != null )
			{
				if( serializationAttributeParameters != null )
				{

#>
	[<#= serializationAttributeName #>( <#= serializationAttributeParameters #> )]
<#+
				}
				else
				{
#>
	[<#= serializationAttributeName #>]
<#+
				}
			}
			if( entityAttributes != null )
			{
#>
	[<#= entityAttributes #>]
<#+
			}

			if( entity.Attribute("JsonConverter") != null )
			{
				var jsonConverterNameAttr = entity.Attribute( "JsonConverter" );
#>
	[JsonConverter( typeof(<#= jsonConverterNameAttr.Value #>) )]
<#+
			}
#>
	<#= visibility #> partial class <#= entity.Attribute( "Name" ).Value #> : <#= ConstructBaseClassType( entity ) #><#+
			if( entity.Attribute( "Interfaces" ) != null )
			{
				var interfaces = entity.Attribute( "Interfaces" ).Value.Split( ',' );
				
				foreach( var i in interfaces )
				{
					#>, <#= i #><#+
				}
			}
#>

	{
		#region Fields
<#+
			var properties = (from p in entity.Elements( NS+"Property" ) select p).ToArray();

			foreach( var property in properties )
			{
				if( GetBooleanAttribute( property, "CreateStorage", true ) )
				{
#>
		[DebuggerBrowsable( DebuggerBrowsableState.Never )] private <#= ConstructPropertyType( property ) #> <#= FieldNameForPropertyNamed( property.Attribute( "Name" ).Value ) #>;
<#+
				}
			}
#>
		#endregion

		#region Properties
<#+
			foreach( var property in properties )
			{
				var pName = property.Attribute( "Name" ).Value;
				
				serializationMode = null;
				serializationName = null;
				visibility = "public";

				if( property.Attribute( "Visibility" ) != null )
				{
					visibility = property.Attribute( "Visibility" ).Value;
				}

				if( property.Attribute( "Serialization" ) != null )
				{
					serializationMode = property.Attribute( "Serialization" ).Value;
				}
				else
				{
					serializationMode = defaultPropertySerializationMode ?? "contract";
				}

				if( property.Attribute( "SerializationName" ) != null )
				{
					serializationName = property.Attribute( "SerializationName" ).Value;
				}

				serializationAttributeName = null;
				serializationAttributeParameters = null;

				switch( serializationMode )
				{
					case "element":
						serializationAttributeName = "XmlElement";

						if( serializationName != null )
						{
							var parts = serializationName.Split( ',' );

							if( parts.Length == 1 )
							{
								serializationAttributeParameters = "\"" + serializationName + "\"";
							}
							else
							{
								serializationAttributeParameters = string.Format( "\"{1}\", Namespace=\"{0}\"", parts[0], parts[1] );
							}
						}

						break;

					case "attribute":
						serializationAttributeName = "XmlAttribute";

						if( serializationName != null )
						{
							var parts = serializationName.Split( ',' );

							if( parts.Length == 1 )
							{
								serializationAttributeParameters = "\"" + serializationName + "\"";
							}
							else
							{
								serializationAttributeParameters = string.Format( "\"{1}\", Namespace=\"{0}\"", parts[0], parts[1] );
							}
						}

						break;

					case "none":
						break;

					case "contract":
					default:
						serializationAttributeName = "DataMember";

						if( serializationName != null )
						{
							serializationAttributeParameters = "Name = \"" + serializationName + "\"";
						}

						break;
				}

				if( serializationAttributeName != null )
				{
					if( serializationAttributeParameters != null )
					{

#>
		[<#= serializationAttributeName #>( <#= serializationAttributeParameters #> )]
<#+
					}
					else
					{
#>
		[<#= serializationAttributeName #>]
<#+
					}
				}

				var propertyAttributes = EmitAttributes( property );
				if( propertyAttributes != null )
				{
#>
		[<#= propertyAttributes #>]
<#+
				}
#>
		<#= visibility #> <#= ConstructPropertyType( property ) #> <#= pName #>
		{
<#+
				if( property.Element( NS+"Code" ) != null )
				{
#>
			<#= property.Element( NS+"Code" ).Value #>
<#+
				}
				else
				{
#>
			get { return <#= FieldNameForPropertyNamed( pName ) #>; }
			set
			{
				if( !object.Equals( <#= FieldNameForPropertyNamed( pName ) #>, value ) )
				{
					OnPropertyChanging( "<#= pName #>", <#= FieldNameForPropertyNamed( pName ) #>, value );
					<#= FieldNameForPropertyNamed( pName ) #> = value;
					OnPropertyChanged( "<#= pName #>" );
				}
			}
<#+
				}
#>
		}
<#+
			}
#>
		#endregion

		#region ProcessCopy
		protected override void ProcessCopy( XObject source, bool cloning, bool deepCloning )
		{
			base.ProcessCopy( source, cloning, deepCloning );

			var other = (<#= entity.Attribute( "Name" ).Value #>) source;

			BeforeProcessCopy( other, cloning, deepCloning );

<#+
			var complex = new List<XElement>();

			foreach( var property in properties )
			{
				if( !GetBooleanAttribute( property, "CreateStorage", true ) )
					continue;

				var updateMode = property.Attribute( "Update" ) == null ? "auto" : property.Attribute( "Update" ).Value;
				
				if( updateMode == "ignore" )
					continue;
				
				bool isSimpleProperty = false;
				
				if( updateMode == "auto" )
					isSimpleProperty = IsSimpleProperty( property );
				else if( updateMode == "assign" )
					isSimpleProperty = true;
				
				if( isSimpleProperty )
				{
#>
			<#= FieldNameForPropertyNamed( property.Attribute( "Name" ).Value ) #> = other.<#= FieldNameForPropertyNamed( property.Attribute( "Name" ).Value ) #>;
<#+
				}
				else
				{
					complex.Add( property );
				}
			}

			if( complex.Count > 0 )
			{
#>

			if( cloning )
			{
<#+
				foreach( var property in complex )
				{
					var pName = property.Attribute( "Name" ).Value;
#>
				<#= FieldNameForPropertyNamed( pName ) #> = other.<#= FieldNameForPropertyNamed( pName ) #> == null ? null : (<#= ConstructPropertyType( property ) #>) other.<#= FieldNameForPropertyNamed( pName ) #>.Clone( deepCloning );
<#+
				}
#>
			}
			else
			{
<#+
				foreach( var property in complex )
				{
					var pName = property.Attribute( "Name" ).Value;
#>
				if( <#= FieldNameForPropertyNamed( pName ) #> != null )
				{
					if( other.<#= FieldNameForPropertyNamed( pName ) #> != null )
					{
						<#= FieldNameForPropertyNamed( pName ) #>.Update( other.<#= FieldNameForPropertyNamed( pName ) #> );
					}
					else
					{
						<#= FieldNameForPropertyNamed( pName ) #> = null;
					}
				}
				else
				{
					if( other.<#= FieldNameForPropertyNamed( pName ) #> != null )
					{
						<#= FieldNameForPropertyNamed( pName ) #> = (<#= ConstructPropertyType( property ) #>) other.<#= FieldNameForPropertyNamed( pName ) #>.Clone( false );
					}
				}
<#+
				}
#>
			}
<#+
			}
#>

			AfterProcessCopy( other, cloning, deepCloning );
<#+
#>
		}

		partial void BeforeProcessCopy( <#= entity.Attribute( "Name" ).Value #> source, bool cloning, bool deepCloning );
		partial void AfterProcessCopy( <#= entity.Attribute( "Name" ).Value #> source, bool cloning, bool deepCloning );
		#endregion
<#+			
			if( entity.Attribute( "XKeyProperties" ) != null && !string.IsNullOrWhiteSpace( entity.Attribute( "XKeyProperties" ).Value ) )
			{
#>
		#region CreateKey
		protected override XKey CreateKey()
		{
			XKey key = base.CreateKey();
			
<#+
				var names = entity.Attribute( "XKeyProperties" ).Value.Split( ',' );
				
				foreach( var pName in names )
				{
#>
			key = key.WithKey( "<#= pName #>", <#= FieldNameForPropertyNamed( pName ) #> );
<#+
				}
#>

			return key;
		}
		#endregion
<#+
			}

			if( GetBooleanAttribute( entity, "GenerateEquals", true ) )
			{
#>
		#region Equals/GetHashCode
		public override bool Equals( object otherObject )
		{
<#+ 
				if( entity.Attribute( "BaseType" ).Value == "XObject" && entity.Attribute( "BaseTypeGenericArguments" ) != null )
				{
#>
			if( !base.Equals( otherObject ) )
			{
				return false;
			}

<#+
				}
#>
			var other = otherObject as <#= entity.Attribute( "Name" ).Value #>;

			if( other == null )
			{
				return false;
			}
<#+
				foreach( var property in properties )
				{
					if( !GetBooleanAttribute( property, "CreateStorage", true ) )
						continue;
#>

			if( !object.Equals( <#= FieldNameForPropertyNamed( property.Attribute( "Name" ).Value ) #>, other.<#= FieldNameForPropertyNamed( property.Attribute( "Name" ).Value ) #> ) )
			{
				return false;
			}
<#+
				}
#>

			return true;
		}

		public override int GetHashCode()
		{
			int hashCode = 17;
<#+
				foreach( var property in properties )
				{
					if( !GetBooleanAttribute( property, "CreateStorage", true ) )
						continue;

					string pName = property.Attribute( "Name" ).Value;

					if( IsValueTypeProperty( property ) )
					{
#>

			hashCode = hashCode * 37 + <#= FieldNameForPropertyNamed( pName ) #>.GetHashCode();
<#+
					}
					else
					{
#>

			if( <#= FieldNameForPropertyNamed( pName ) #> != null )
			{
				hashCode = hashCode * 37 + <#= FieldNameForPropertyNamed( pName ) #>.GetHashCode();
			}
<#+
					}
				}
#>

			return hashCode;
		}
		#endregion
<#+
			}

			if( entity.Element( NS+"Code" ) != null )
			{
#>
		#region Custom Code
<#= entity.Element( NS+"Code" ).Value #>
		#endregion
<#+
			}
			
			var innerEntities = from e in entity.Elements( NS+"Entity" ) select e;

#>
		
<#+		
			PushIndent( "\t" );
			ProcessEntities( innerEntities );
			PopIndent();
#>
	}
	#endregion
<#+
		}
	}
#>